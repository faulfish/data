// SerialIO.cpp: implementation of the CSerialIO class.
// 2004/10/11
// Change std::string to character string
//////////////////////////////////////////////////////////////////////
#define STRICT

#include "stdafx.h"
#include <crtdbg.h>
#include <tchar.h>
#include <stdio.h>
#include "SerialIO.h"
#include "Logger.h"


#define READ_BUFFER_LEN	100
#define RF_ANALOG_MODE	0
#define CMDIAG_MODE_OFFLINE_A_F  0	/* Go to offline analog */
#define CMDIAG_MODE_OFFLINE_D_F	 1   /* Go to offline digital */
#define DIAG_OFFLINE_DIGITAL 2
#define DIAG_OFFLINE_ANALOG  6
#define MODE_DETECTION_RETY_TIMES 20
#define MODE_DETECTION_DELAY	1000
#define SERIAL_QUEUE_SIZE		4096


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CSerialIO::CSerialIO() : m_lLastError(ERROR_SUCCESS),
						 m_hFile(NULL),
						 m_hWriteEvent(NULL),
						 m_fStopping(0),
						 m_hThread(NULL),
						 m_hReadEvent(NULL),
						 m_eState(EStop),
						 m_bDestroy(FALSE),
						 m_dwBufStart(0),
						 m_dwBufEnd(0),
						 m_dwCOMNum(0),
						 m_hWaitEvent(NULL),
						 m_bIsCOMReopen(TRUE)
{
	LPCTSTR szFunc = _T("CSerialIO::CSerialIO");
	LogFunctionInformation(LOG_LEVEL_DEBUG, szFunc, _T("Start constructor."));
	m_dwBufSize = RECV_BUFFER_SIZE;
	m_pbRecvBuf = new BYTE [m_dwBufSize];
	ZeroMemory(m_pbRecvBuf, m_dwBufSize);
	ZeroMemory(m_szDevice, sizeof(TCHAR) * COM_PORT_NAME_LENGTH);
	ZeroMemory(m_szCOM, sizeof(TCHAR) * COM_PORT_NAME_LENGTH);
	m_dwCurWriteCount = 0;
	m_bIsPreventOuterRead = FALSE;
	m_bIsPreventOuterWrite = FALSE;
	m_bIsReOpen = FALSE;
	m_TestSpeed[0]= EBaud115200;
	m_TestSpeed[1]= EBaud230400;
	m_TestSpeed[2]= EBaud460800;
	m_ePreferBaudRate = EBaud115200;
	m_nCurrentSpeedTry = 0;

}

CSerialIO::~CSerialIO()
{
	LPCTSTR szFunc = _T("CSerialIO::~CSerialIO");
	LogFunctionInformation(LOG_LEVEL_DEBUG, szFunc, _T("Start destructor"));
	m_bDestroy = TRUE;
	LogFunctionInformation(LOG_LEVEL_DEBUG, szFunc, _T("Start stopping listener."));
	StopListener(INFINITE);

	LogFunctionInformation(LOG_LEVEL_DEBUG, szFunc, _T("Start internal close."));
	InternalClose();
	_ASSERTE(m_pbRecvBuf != NULL);
	LogFunctionInformation(LOG_LEVEL_DEBUG, szFunc, _T("Start free read buffer."));
	delete[] m_pbRecvBuf;
	m_pbRecvBuf = NULL;
	LogFunctionInformation(LOG_LEVEL_DEBUG, szFunc, _T("complete destructor."));
}

LONG CSerialIO::Open(LPCTSTR lpszDevice, EBaudrate eBaudrate)
{
	LPCTSTR szFunc = _T("CSerialIO::Open");

	_ASSERTE(lpszDevice != NULL);
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, lpszDevice, szFunc, _T("Start open operation."));

	m_lLastError = ERROR_SUCCESS;

	if (m_hFile)
	{
		m_lLastError = ERROR_ALREADY_INITIALIZED;
		return m_lLastError;
	}

	//+ rick huang 2004/09/07
	//+ add for comport > = 10
	//+ {
	// 2004/10/11 Embert Tsai
	// Remove std::string support.
	ZeroMemory(m_szDevice, sizeof(TCHAR) * COM_PORT_NAME_LENGTH);
	ZeroMemory(m_szCOM, sizeof(TCHAR) * COM_PORT_NAME_LENGTH);

	m_dwCOMNum = GetCOMNum(lpszDevice);
	_stprintf(m_szCOM, _T("COM%d"),m_dwCOMNum);
	if ( m_dwCOMNum > 9 ){	// COM port number larger than 9, add prefix string.
		_stprintf(m_szDevice, _T("\\\\.\\COM%d"),m_dwCOMNum);
	} else{
		_stprintf(m_szDevice, _T("COM%d"),m_dwCOMNum);
	}

	m_eBaudrate = eBaudrate;
	StartListener();

	return m_lLastError;
}

LONG CSerialIO::Close(void)
{
	LPCTSTR szFunc = _T("CSerialIO::Close");
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Try to close com port."));
	m_lLastError = ERROR_SUCCESS;
        // 20041110 Embert Tsai
        // Move stop listener to front.
	StopListener();
	if (m_hFile == 0)
	{
		return m_lLastError;
	} else {
		if ( InternalClose() != ERROR_SUCCESS ){
			LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("internal close failed."));			
		} else {
			LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Close com port successfully."));			
			return RUN_SUCCESSFULLY;
		}
	}

	LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Close COM port failed."));
	return m_lLastError;
}

BOOL CSerialIO::ChangeToDSMode(void)
{
	LPCTSTR szFunc = _T("CSerialIO::ChangeToDSMode");
	switch ( m_eState ){
	case EDL:
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Can not change mode from DL to DS."));
		return FALSE;
	case EDIAG:
		return ChangeDIAG2DS();
	case EDS:
		return TRUE;
	}
	_ASSERTE(FALSE);
	return FALSE;
}

BOOL CSerialIO::ChangeToDIAGMode(void)
{
	LPCTSTR szFunc = _T("CSerialIO::ChangeToDIAGMode");
	switch ( m_eState ){
	case EDL:
		LogCOMFuncInfo(LOG_LEVEL_ERROR,m_szCOM, szFunc, "Can not change mode from DL to DIAG.");
		return FALSE;
	case EDIAG:
		return TRUE;
	case EDS:
		return ChangeDS2DIAG();
	default:
		_ASSERTE(FALSE);
		return FALSE;
	}
	_ASSERTE(FALSE);
	return FALSE;
}

// 20040916 Embert Tsai
BOOL CSerialIO::ChangeToDLMode(void){
	switch ( m_eState ) {
	case EDL:
		return TRUE;
	case EDIAG:
		return ChangeDIAG2DL();
	case EDS:
		return ChangeDS2DL();
	default:
		_ASSERTE(FALSE);
		return FALSE;
	}
}


LONG CSerialIO::Write(const void* pData, size_t iLen, DWORD* pdwWritten)
{
	LPCTSTR szFunc = _T("CSerialIO::Write");
	_ASSERTE( pData != NULL );
	_ASSERTE( iLen > 0 );
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Start write operation."));
	if ( m_bIsPreventOuterWrite)	//Prevent outer class to write packet
		return -1;
	::InterlockedIncrement(&m_dwCurWriteCount);

	long lRet = 0;
	lRet = InternalWrite(pData, iLen, pdwWritten);
	
	::InterlockedDecrement(&m_dwCurWriteCount);
	return lRet;
}

LONG CSerialIO::Read(void* pData, size_t iLen, DWORD* pdwRead)
{
	_ASSERTE(pData != NULL);
	_ASSERTE(iLen > 0);
	LPCTSTR szFunc = _T("CSerialIO::Read");
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Start read operation."));
	m_lLastError = ERROR_SUCCESS;

	DWORD dwRead;
	if (pdwRead == 0)
	{
		pdwRead = &dwRead;
	}
	*pdwRead = 0;

	if (m_hFile == 0)
	{
		m_lLastError = ERROR_INVALID_HANDLE;
		return m_lLastError;
	}

#ifdef _DEBUG
	//memset(pData,0xDC,iLen);
	FillMemory(pData, iLen, 0xDC);
#endif
	m_csRead.Lock();

	//*pdwRead = iLen <= m_strRecv.length() ? iLen : m_strRecv.length();
	//memcpy(pData, m_strRecv.data(), *pdwRead);
	//m_strRecv.erase(0, *pdwRead);

	*pdwRead = ReadBuffer(pData,iLen);

	m_csRead.Unlock();

	return m_lLastError;
}

LONG CSerialIO::InternalOpen()
{
	LPCTSTR szFunc = _T("CSerialIO::InternalOpen");
	m_lLastError = ERROR_SUCCESS;

	// Search Registry to detemine weather 
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Check COM port existence in the Registry."));
	if ( !IsCOMPortAlive()){
		LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("COM port is not found in the Registry."));
		::Sleep(1000);
		return -1;
	}

	m_eBaudrate = m_TestSpeed[m_nCurrentSpeedTry++];

	if ( m_nCurrentSpeedTry == SPEED_ARRAY_SIZE ){
		m_nCurrentSpeedTry = 0;
	}

	m_csWrite.Lock();
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Start InternalOpen."));
	if (m_hFile)
	{
		m_lLastError = ERROR_ALREADY_INITIALIZED;
		m_csWrite.Unlock();
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("COM port has been opened."));
		return m_lLastError;
	}

	// Open the device
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Start create file."));
	m_hFile = ::CreateFile(m_szDevice,
						   GENERIC_READ|GENERIC_WRITE|MAXIMUM_ALLOWED,
						   0,
						   0,
						   OPEN_EXISTING,
						   FILE_FLAG_OVERLAPPED,
						   0);

	if (m_hFile == INVALID_HANDLE_VALUE)
	{
		m_hFile = 0;
		m_lLastError = ::GetLastError();
		// modified by Embert
		// record error information
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Fails in opening COM port."));
		LogCOMFuncSystemError( m_szCOM, szFunc,m_lLastError);
		m_csWrite.Unlock();
		return m_lLastError;
	}

	if ( ERROR_SUCCESS != InternalResetCOM()){
		if ( !::CloseHandle(m_hFile) ){
			LogCOMFuncSystemError( m_szCOM, szFunc, GetLastError());
		}
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Close COM port successfully."));
		m_hFile = NULL;
		m_csWrite.Unlock();
		return m_lLastError;	
	}

	// create overlapped event
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Create write event."));
	m_hWriteEvent = ::CreateEvent(0, FALSE, FALSE, 0);
	if (m_hWriteEvent == 0)
	{
		long lLastError = ::GetLastError();

		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("::CreateEvent Write event failed."));
		LogCOMFuncSystemError( m_szCOM, szFunc, lLastError);
		if ( !::CloseHandle(m_hFile) ){
			LogCOMFuncSystemError( m_szCOM, szFunc, GetLastError());
		}
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Close COM port successfully."));

		m_hFile = NULL;

		m_lLastError = lLastError;
		m_csWrite.Unlock();
		return m_lLastError;
	}

	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Create read event."));
	m_hReadEvent = ::CreateEvent(0, FALSE, FALSE, 0);
	if (m_hReadEvent == 0)
	{
		long lLastError = ::GetLastError();

		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Create read event failed."));
		LogCOMFuncSystemError(m_szCOM, szFunc, lLastError);
		if ( !::CloseHandle(m_hFile) ){
			LogCOMFuncSystemError(m_szCOM,szFunc,GetLastError());
		}
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Close COM port successfully."));
		m_hFile = NULL;

		m_lLastError = lLastError;
		m_csWrite.Unlock();
		return m_lLastError;
	}

	m_csWrite.Unlock();
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Start InternalOpen Completed."));
	
	return m_lLastError;
}

LONG CSerialIO::InternalClose(void)
{
	LPCTSTR szFunc = _T("CSerialIO::InternalClose");
	m_csWrite.Lock();

	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("InternalClose start."));	
	m_lLastError = ERROR_SUCCESS;
	if (m_hFile == 0)
	{
		m_csWrite.Unlock();
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("COM port handle is null."));
		return m_lLastError;
	}

	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Try to close COM port."));
	if ( !::CloseHandle(m_hFile) ){
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Close COM port failed."));
		m_lLastError = GetLastError();
		LogCOMFuncSystemError(m_szCOM,szFunc,m_lLastError);
	}
	
	m_hFile = 0;

	if (m_hWriteEvent)
	{
		if ( ! ::CloseHandle(m_hWriteEvent) ){
			LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Close write event failed."));
			m_lLastError = GetLastError();
			LogCOMFuncSystemError(m_szCOM, szFunc, m_lLastError);
            return m_lLastError;
		}
		m_hWriteEvent = 0;
	}

	if (m_hReadEvent)
	{
		if ( !::CloseHandle(m_hReadEvent) ){
			LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Close write event failed."));
			m_lLastError = GetLastError();
			LogCOMFuncSystemError(m_szCOM, szFunc, m_lLastError);
            return m_lLastError;
		}
		m_hReadEvent = 0;
	}

	m_csWrite.Unlock();
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Close COM port successfully."));
	return m_lLastError;
}

CSerialIO::EBaudrate CSerialIO::GetBaudrate()
{
	LPCTSTR szFunc = _T("CSerialIO::GetBaudrate");
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Start get COM port Baud rate."));
	if ( m_eState != EDIAG && m_eState != EDL  && m_eState != EDS ) 
		return EBaudUnknown;

	m_lLastError = ERROR_SUCCESS;
	if (m_hFile == 0)
	{
		m_lLastError = ERROR_INVALID_HANDLE;
		return EBaudUnknown;
	}
	DCB dcb;
	dcb.DCBlength = sizeof (DCB);
	if (!::GetCommState(m_hFile,&dcb))
	{
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Can not get com port state."));
		m_lLastError = ::GetLastError();
		LogCOMFuncSystemError(m_szCOM, szFunc, m_lLastError);
		return EBaudUnknown;
	}
	return EBaudrate(dcb.BaudRate);
}

LONG CSerialIO::StartListener (void)
{
	LPCTSTR szFunc = _T("CSerialIO::StartListener");
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Start listener."));
	if (m_hThread == 0)
	{
		_ASSERTE(!m_fStopping);
		DWORD dwThreadId = 0;
		m_hThread = ::CreateThread(0,0,ThreadProc,LPVOID(this),0,&dwThreadId);
		if (m_hThread == 0)
		{
			m_lLastError = ::GetLastError();
			LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Start listener failed."));
			LogCOMFuncSystemError(m_szCOM, szFunc, m_lLastError);
			return m_lLastError;
		}
		// add code to wait for create create complete
	} else {
		LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Thread has already existed."));
	}
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Start listener completed."));
	m_lLastError = ERROR_SUCCESS;
	return m_lLastError;
}

LONG CSerialIO::StopListener (DWORD dwTimeout)
{
	LPCTSTR szFunc = _T("CSerialIO::StopListener");
	if (m_hThread)
	{
		m_fStopping = TRUE;
		LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Start stop listen thread."));
		SetEvent(m_hReadEvent);
		::WaitForSingleObject(m_hThread,dwTimeout);
		LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Complete stop listen thread."));
		m_fStopping = FALSE;
		::CloseHandle(m_hThread);
		m_hThread = 0;
		// 20050823 Embert Tsai.
		// set the com state to start
		m_eState = EStart;
	} else {
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Listen thread is null, so no stop operation."));
	}

	m_lLastError = ERROR_SUCCESS;
	return m_lLastError;
}

BOOL CSerialIO::SendProbe(void)
{
	LPCTSTR szFunc = _T("CSerialIO::SendProbe");
	UCHAR szBuffer[10];
	DWORD dwWrited = 0;
	szBuffer[0] = 0x61;
	szBuffer[1] = 0x74;
	szBuffer[2] = 0x0d;
	szBuffer[3] = 0x1c;
	szBuffer[4] = 0xd5;
	szBuffer[5] = 0x7e;
	// 20040921 Embert Tsai. The following command is download ack command.
	szBuffer[6] = 0x06;
	szBuffer[7] = 0x4E;
	szBuffer[8] = 0x95;
	szBuffer[9] = 0x7E;

	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Write detection packet to com port."));
	if( InternalWrite(szBuffer, 10, &dwWrited) != ERROR_SUCCESS || dwWrited != 10 )
	{
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Write detection packet to com port failed."));
		return FALSE;
	}
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Write detection packet successfully."));
	return TRUE;
}

DWORD WINAPI CSerialIO::ThreadProc (LPVOID lpArg)
{
	CSerialIO* pThis = reinterpret_cast<CSerialIO*>(lpArg);
	return pThis->ThreadProc();
}

DWORD CSerialIO::ThreadProc (void)
{
	LPCTSTR szFunc = _T("CSerialIO::ThreadProc");
	char szBuffer[4096];
	OVERLAPPED ovInternal = {0};
	DWORD dwRead = 0;
	//+ 12/31/2003 Rick
	//+ add this boolean for target at streaming
	//+ mode and throw out msg/log/event continully
	BOOL bContinueRecv = FALSE;

	m_eState = EStart;

	if(m_bDestroy != TRUE)
	{
		LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Send START notification."));
		OnEvent(EOnStart);
	}

	do
	{
		if(m_eState == EStart)
		{
			//+ 12/31/2003 Rick
			//+ add this judgment for target at streaming
			//+ mode and throw out msg/log/event continully
			//+ bContinueRecv == FALSE means no data received 
			// 20040921 Embert Tsai
			// Device open fails, try again and again.
			if( (bContinueRecv == FALSE) && m_bIsCOMReopen)
			{
				LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Start InternalClose()."));
				InternalClose();
				::Sleep(100);	// Added by Embert to let driver have more time to start up
				LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Start InternalOpen()."));
				if(InternalOpen() != ERROR_SUCCESS)
				{
					LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("InternalOpen() failed."));
					::Sleep(500);
					continue;
				};
			}
				ovInternal.hEvent = m_hReadEvent;
			Sleep(100); // Let driver have enough time to response.
			SendProbe();
			//::Sleep(500);	// Wait for Tx packet processing completed.
		}

		if (!::ReadFile(m_hFile, szBuffer, 4096, &dwRead, &ovInternal))
		{
			long lLastError = ::GetLastError();
			if (lLastError != ERROR_IO_PENDING)
			{
				// COMM port disconnected.
				if(m_eState != EStart && m_bDestroy != TRUE)
				{
					m_eState = EStart;
					LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Send START notification."));
					OnEvent(EOnStart);
				}
				m_eState = EStart;
				m_lLastError = lLastError;
				bContinueRecv = FALSE;
				LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Read com port data error."));
				LogCOMFuncSystemError(m_szCOM, szFunc, m_lLastError);
				Sleep(500);
			}
			else
			{
				switch (::WaitForSingleObject(ovInternal.hEvent,INFINITE))
				{
				case WAIT_OBJECT_0:
					if (!::GetOverlappedResult(m_hFile,&ovInternal,&dwRead,FALSE))
					{
						m_lLastError = ::GetLastError();
					}
					else
					{
						if(dwRead != 0)
						{
							// Read Data
							LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Read COM port buffer."));
							LogCOMFuncBuffer(LOG_LEVEL_DEBUG, m_szCOM, szFunc, szBuffer, dwRead);
						
							if(m_eState == EStart)
							{
								LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Mobile mode detection."));
																
								if( dwRead >= sizeof(DETECT_DS_RSP)-1 &&
									memcmp(szBuffer, DETECT_DS_RSP, sizeof(DETECT_DS_RSP)-1) == 0)
								{
									m_eState = EDS;
									if(m_bDestroy != TRUE)
									{
										LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Send DS notification."));
										OnEvent(EOnConnectDS);
									}
								}
								else if( (dwRead >= sizeof(DETECT_DIAG_RSP_5105)-1 && memcmp(szBuffer, DETECT_DIAG_RSP_5105, sizeof(DETECT_DIAG_RSP_5105)-1) == 0) ||
										 (dwRead >= sizeof(DETECT_DIAG_RSP_6250)-1 && memcmp(szBuffer, DETECT_DIAG_RSP_6250, sizeof(DETECT_DIAG_RSP_6250)-1) == 0) )
								{
									m_eState = EDIAG;
									if(m_bDestroy != TRUE)
									{
										LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Send DIAG notification."));
										OnEvent(EOnConnectDIAG);
									}
								}
								else if (dwRead >= sizeof(DETECT_DL)-1 &&
									memcmp(szBuffer, DETECT_DL, sizeof(DETECT_DL)-1) == 0)
								{
									m_eState = EDL;
									if(m_bDestroy != TRUE)
									{
										LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Send DL notification."));
										OnEvent(EOnConnectDL);
									}
								}
								else
								{
									LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Can not determine phone mode by return buffer."));

									//+ 12/31/2003 Rick
									//+ bContinueRecv = TRUE means
									//+ receive data but dont know what mode the 
									//+ target is 
									bContinueRecv = TRUE;
								}
							}
							else
							{
								static UINT uiTest = 0;
								m_csRead.Lock();
								LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Transfer content to CSIOChannel with current mode %d"), m_eState);
								AppendBuffer(szBuffer,dwRead);
								m_csRead.Unlock();
								if(m_bDestroy != TRUE)
								{
									if ( !m_bIsPreventOuterRead ){
										LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Send read notification."));
										OnEvent(EOnRecv);
									}
								}
								uiTest += dwRead;
							}
						}
					}

					break;

				case WAIT_TIMEOUT:
					_ASSERTE(FALSE);
					LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Read operation time out."));
					::CancelIo(m_hFile);
					m_lLastError = ERROR_TIMEOUT;
					m_fStopping = TRUE;
					break;

				default:
					_ASSERTE(FALSE);
					LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Read operation time out."));
					m_lLastError = ::GetLastError();
					LogCOMFuncSystemError(m_szCOM, szFunc, m_lLastError);
					m_fStopping = TRUE;
					break;
				}
			}
		}
	}
	while (!m_fStopping);

	InternalClose();

	if ( !m_bIsReOpen)
		m_eState = EStop;
	if(m_bDestroy != TRUE && !m_bIsReOpen)
	{
		LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Send STOP notification."));
		OnEvent(EOnStop);
	}
	// Bye bye
	return 0;
}

// 20040913 Change DS mode to DIAG mode
BOOL CSerialIO::ChangeDS2DIAG(void){

	LPCTSTR szFunc = _T("CSerialIO::ChangeDS2DIAG");
	_ASSERTE(m_eState == EDS);
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc,_T("Start change mode DS to DIAG"));
	
	if(!InternalWrite("at$qcdmg\r", strlen("at$qcdmg\r")))
	{
		StopListener();
		StartListener();
		int i = 0;
		while( (i++) < 100 )
		{
			switch(m_eState)
			{
			case EStop:
			case EStart:
				break;
			case EDS:
				return FALSE;
			case EDIAG:
				return TRUE;
			case EDL:
				return FALSE;
			}
			Sleep(200);
		}
		return FALSE;
	}

	return FALSE;

}

// Change DIAG mode to DS mode
BOOL CSerialIO::ChangeDIAG2DS(void){

	LPCTSTR szFunc = _T("CSerialIO::ChangeDIAG2DS");
	_ASSERTE( m_eState == EDIAG );
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc,_T("Start changing mode from DIAG to DS"));
	if(	// CMD_CODE 31 Message Request
		!InternalWrite("\x1f\xff\x00\x5e\xf6\x7e", sizeof("\x1f\xff\x00\x5e\xf6\x7e")-1) &&
		// CMD_CODE 93 Extended Logging Mask Request
		//!Write("\x5d\x1a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe6\x64\x7e", sizeof("\x5d\x1a\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xe6\x64\x7e")) &&
		// CMD_CODE 115 Logging Configuration Request
		!InternalWrite("\x73\x00\x00\x00\x00\x00\x00\x00\xda\x81\x7e", sizeof("\x73\x00\x00\x00\x00\x00\x00\x00\xda\x81\x7e")-1) &&
		// CMD_CODE 68 Serial Mode Change Request
		!InternalWrite("\x44\x58\xf4\x7e", sizeof("\x44\x58\xf4\x7e")-1) )
	{
		StopListener();
		StartListener();
		int i = 0;
		while((i++)<100)
		{
			switch(m_eState)
			{
			case EStop:
			case EStart:
				break;
			case EDS:
				return TRUE;
			case EDIAG:
				return FALSE;
			case EDL:
				return FALSE;
			}
			Sleep(200);
		}
		return FALSE;
	}
	return FALSE;

}

////////////////////////////////////////////////////////////////////////
// 20040916 Embert Tsai
// This is not allowed in current situation. (5150 and 6250)
///////////////////////////////////////////////////////////////////////
BOOL CSerialIO::ChangeDL2DIAG(void){
	LPCTSTR szFunc = _T("CSerialIO::ChangeDL2DIAG");
	_ASSERTE(m_eState == EDL );
	LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc,_T("This operation is not allowed."));
	return FALSE;
}

////////////////////////////////////////////////////////////////////////
// 20040916 Embert Tsai
// 1. First change mobile to offline.
// 2. Send DIAG cmd to change to DL mode.
///////////////////////////////////////////////////////////////////////
BOOL CSerialIO::ChangeDIAG2DL(void){

	LPCTSTR szFunc = _T("CSerialIO::ChangeDIAG2DL");
	_ASSERTE(m_eState == EDIAG);

	CSerialIO::EPlatform EPlatform;
	EPlatform = GetPlatformID();
	switch(EPlatform){
		case (CSerialIO::E_PLAT_6280):
			InternalChange2DL6280();
			break;
		case(CSerialIO::E_PLAT_DEFAULT):
			InternalChange2DLDefault();
				break;
		default:
			_ASSERTE(FALSE);
		}
		return FALSE;
	}

BOOL CSerialIO::ChangeDS2DL(void){
	LPCTSTR szFunc = _T("CSerialIO::ChangeDS2DL");
	BOOL bRet = FALSE;
	if ( ! ChangeDS2DIAG() ){
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Change DS to DIAG fails."));
		return FALSE;
	}
	if ( ! ChangeDIAG2DL() ) {
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Change DIAG to DL fails."));
		return FALSE;
	}
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////
/*************************************************************************
 * Purpose: Change phone to offline mode.
 * Input  : NONE
 * Return : TRUE -->run succesfully.
 *			FALSE  -->error.
 * Exception: This function is called for Domingo model. Although it does not 
			  Work in Ulysses mode. But it does not have other side effect.
 * Note	  : 2004/09/21 first version created by Embert
 ***************************************************************************/
////////////////////////////////////////////////////////////////////////////
BOOL CSerialIO::ChangeToOffline(){

	LPCTSTR szFunc = _T("CSerialIO::ChangeToOffline");
	_ASSERTE(m_eState == EDIAG);
	DWORD dwWriteByte	=	0;
	DWORD dwReadByte	=	0;
	DWORD wEntryReason	=	0;
	int nTestCount = 20;
	
	// First detect phone status
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Change mobile to offline mode"));
	BYTE pbCMDStatus[4] = {0x0C,0x14,0x3A,0x7E};
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc , _T("Get phone status"));
	if ( (InternalWrite(pbCMDStatus,4, &dwReadByte) != ERROR_SUCCESS) || (dwReadByte != 4) ){
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc,"Write fails");
		LogCOMFuncBuffer(LOG_LEVEL_ERROR, m_szCOM, szFunc,  pbCMDStatus, 4);
		return FALSE;
	}
	
	BYTE pbCMDRsp[READ_BUFFER_LEN];
	ZeroMemory(pbCMDRsp,READ_BUFFER_LEN);
	//while ( m_strRecv.length() == 0 ) ;	// Waiting for Reading buffer completion
	//Sleep(100);
    // 20050118 Embert Tsai
	if ( WaitandReadBuffer(pbCMDRsp, READ_BUFFER_LEN, 51, &dwReadByte) != ERROR_SUCCESS ){
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, "Read fails");
		return FALSE;
	}
	if ( pbCMDRsp[0] != 0x0C ){
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, "Can\'t get phone status, Maybe it is a Ulysses handset.");
		return TRUE;	// It is a very tricky. 
	}
	
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Set mobile offline."));
	WORD wRFMode = 0;
	BYTE pbCMDOffline[6];
	ZeroMemory(pbCMDOffline, 6);
	// Get RF mode
	int nReadCount = 0;
	int nIndex = 0;
	int nRFIndex = 0;
	int nEntryIndex = 0;
	while (TRUE){
		if ( pbCMDRsp[nIndex] != 0x7D){
			nIndex++;
			nReadCount++;
		}else{
			nIndex++;
		}
		if ( 8 == nReadCount ){		//Original RF mode value position.
			nRFIndex = nIndex;
			break;
		}
	}

	CopyMemory( &wRFMode, pbCMDRsp + nRFIndex , 2); 
	if ( wRFMode == RF_ANALOG_MODE ){ /* Go to offline analog */
		// The following code should be fixed to meet analog mode.
		pbCMDOffline[0]=0x29;
		pbCMDOffline[1]=0x01;
		pbCMDOffline[2]=0x00;
		pbCMDOffline[3]=0x31;
		pbCMDOffline[4]=0x40;
		pbCMDOffline[5]=0x7E;
	}else{ /* Go to offline digital */
		pbCMDOffline[0]=0x29;
		pbCMDOffline[1]=0x01;
		pbCMDOffline[2]=0x00;
		pbCMDOffline[3]=0x31;
		pbCMDOffline[4]=0x40;
		pbCMDOffline[5]=0x7E;
	}

	// Set mobile phone offline
	dwWriteByte = 0;

	if ( InternalWrite(pbCMDOffline, 6 , &dwWriteByte) != ERROR_SUCCESS || (dwWriteByte != 6 )) {
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Write fails"));
		LogCOMFuncBuffer(LOG_LEVEL_ERROR, m_szCOM, szFunc,  pbCMDOffline, 6);
		return FALSE;
	}
	
	dwReadByte = 0;
	ZeroMemory(pbCMDRsp,READ_BUFFER_LEN);
	//while ( m_strRecv.length() == 0 );
	//Sleep(100);
    // 20050118 Embert Tsai
	if ( WaitandReadBuffer(pbCMDRsp, READ_BUFFER_LEN, 6, &dwReadByte) != ERROR_SUCCESS ){
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Read fails"));
		return FALSE;
	}

	if ( memcmp(pbCMDOffline, pbCMDRsp, 6 ) != 0 ){
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Command fails. Return buffer is wrong."));
		LogCOMFuncBuffer(LOG_LEVEL_ERROR, m_szCOM, szFunc,  pbCMDRsp,6);

		return FALSE;
	}
	
	while ( nTestCount > 0 ) {
		Sleep(200);
		nTestCount --;
		// dectec phone mode
		LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Get current phone status."));
		if ( (InternalWrite(pbCMDStatus,4, &dwReadByte) != ERROR_SUCCESS) || (dwReadByte != 4) ){
			LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM , szFunc,_T("Write fails"));
			LogCOMFuncBuffer(LOG_LEVEL_ERROR, m_szCOM, szFunc,  pbCMDStatus, 4);
			return FALSE;
		}
	
		BYTE pbCMDRsp[READ_BUFFER_LEN];
		ZeroMemory(pbCMDRsp,READ_BUFFER_LEN);
                // 20041110 Embert Tsai
		if ( WaitandReadBuffer(pbCMDRsp, READ_BUFFER_LEN, 51, &dwReadByte) != ERROR_SUCCESS ){
			LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Read fails"));
			return FALSE;
		}
		if ( pbCMDRsp[0] != 0x0C ){
			LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Fails in get phone status"));
			return FALSE;	
		}
		// 20050720 Embert Tsai.
		// Skip 0x7D in front of RF mode data.
		nReadCount = 0;
		nIndex = 0;
		nRFIndex = 0;
		nEntryIndex = 0;
		while (TRUE){
			if ( pbCMDRsp[nIndex] != 0x7D){
				nIndex++;
				nReadCount++;
			}else{
				nIndex++;
			}
			if ( 8 == nReadCount ){		//Original RF mode value position.
				nRFIndex = nIndex;
			}
			if ( 32 == nReadCount){		//Original Entry Reason value position.
				nEntryIndex = nIndex;
				break;
			}
		}
		CopyMemory( &wRFMode, pbCMDRsp+nRFIndex , 2);
		CopyMemory( &wEntryReason, pbCMDRsp+nEntryIndex, 2);		
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, "Current RF mode is %d", wRFMode);
		if( ( wRFMode == CMDIAG_MODE_OFFLINE_A_F && wEntryReason == DIAG_OFFLINE_ANALOG) ||
				( wRFMode == CMDIAG_MODE_OFFLINE_D_F && wEntryReason == DIAG_OFFLINE_DIGITAL))
		{
			return TRUE;
		}

	}
	return FALSE;
}

// 20041110 Embert Tsai
// Change read buffer operation to reduce memory operation.
int CSerialIO::ReadBuffer(void* pvDest, int nLen){
	int nRet;
	DWORD dwBufLen = m_dwBufEnd - m_dwBufStart;
	nRet = nLen <= (int) dwBufLen ? nLen : (int)dwBufLen;
	CopyMemory(pvDest, m_pbRecvBuf+m_dwBufStart, nRet);
	m_dwBufStart += nRet;

	return nRet;
}

// 20041110 Embert Tsai
// Change read buffer operation to reduce memory operation.
int CSerialIO::AppendBuffer(const void* pvSrc, int nLen){
	
	LPCTSTR szFunc = _T("CSerialIO::AppendBuffer");
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Add read content to buffer."));

	if ( ( nLen + ( m_dwBufEnd - m_dwBufStart ) ) > m_dwBufSize  ){ // buffer size is tool small to contain the buffer
			BYTE *pbOld = m_pbRecvBuf;
			m_dwBufSize += ((nLen/RECV_BUFFER_SIZE)+1) * RECV_BUFFER_SIZE;
			m_pbRecvBuf = new BYTE[m_dwBufSize];
			ZeroMemory(m_pbRecvBuf, m_dwBufSize);
		if ( m_dwBufStart != m_dwBufEnd)	// Check buffer is empty.
			CopyMemory(m_pbRecvBuf, pbOld + m_dwBufStart, m_dwBufEnd-m_dwBufStart);
		
		m_dwBufEnd -= m_dwBufStart;
		m_dwBufStart = 0;
		delete[] pbOld;
		pbOld = NULL;
	} else if ( ( m_dwBufEnd + nLen )  >=  m_dwBufSize) {
		MoveMemory(m_pbRecvBuf, m_pbRecvBuf + m_dwBufStart, m_dwBufEnd - m_dwBufStart);
		m_dwBufEnd -= m_dwBufStart;
		m_dwBufStart = 0;
	}
	CopyMemory(m_pbRecvBuf+m_dwBufEnd,pvSrc, nLen );
	m_dwBufEnd += nLen;
	if ( m_hWaitEvent != NULL ){
		::SetEvent(m_hWaitEvent);
	}
	return nLen;

}

// 20050113 Embert Tsai
// Add this method for Topaz download
int CSerialIO::ChangeBaudRate(EBaudrate eBaudRate){
	StopListener();
	Sleep(2000);
	m_ePreferBaudRate = eBaudRate;
	m_nCurrentSpeedTry = GetSpeedIndex(m_ePreferBaudRate);
	StartListener();
	return RUN_SUCCESSFULLY;
}

// 20050223 Embert Tsai
// Add this method for Ulysses download
int CSerialIO::ReOpen(){
	LPCTSTR szFunc = _T("CSIODLLib2::ReOpen");
	int i = 1;
	m_bIsReOpen = TRUE;
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Start reopen......"));
	StopListener();
	Sleep(500);	
	m_ePreferBaudRate = m_eBaudrate;
	m_nCurrentSpeedTry = GetSpeedIndex(m_ePreferBaudRate);
	for ( i = 1 ; i< 10 ; i+=i){
		if ( InternalOpen() != ERROR_SUCCESS ){
			Sleep(i * 1000);	// 2004/09/21 Embert Tsai. Give mobile and driver more time to change to download mode.
		} else {
			break;
		}
	}
	m_bIsReOpen = FALSE;
	if ( i > 10 )
		return -1;
	
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Complete reopen......"));
	
	return RUN_SUCCESSFULLY;
}

// 20050215 Embert Tsai
// This function is used to detect com port status by searching registry key.
BOOL CSerialIO::IsCOMPortAlive(){

	TCHAR szValueName[128] = _T("");
	TCHAR szValueData[128] = _T("");
	DWORD retCode = 0;
	int i = 0;
	HKEY   hkEnum=NULL;
	ULONG ulValueNameLength = 128, ulValueDataLength = 128;
	int nCurrentPortNum = 0;

	retCode = RegOpenKeyEx(HKEY_LOCAL_MACHINE,"HARDWARE\\DEVICEMAP\\SERIALCOMM",0,KEY_QUERY_VALUE,&hkEnum);

	for (i = 0; ; i++)
	{
		ulValueNameLength = 128;
		ulValueDataLength = 128;
		retCode = RegEnumValue(hkEnum, i, szValueName, &ulValueNameLength, NULL, NULL, (unsigned char *)szValueData, &ulValueDataLength);
		if(retCode != ERROR_SUCCESS)
		{
			break;
		}

		if ( GetCOMNum(szValueData) == (int)m_dwCOMNum ){
			// found the COM port
			return TRUE;
		}
		
	}

	return FALSE;
}

// 20050215 Embert Tsai.
// Translate COM string to COM port number
int	CSerialIO::GetCOMNum(LPCTSTR szDevice){
	TCHAR szCOMNum[COM_PORT_NAME_LENGTH] = {0};
	TCHAR szDeviceName[COM_PORT_NAME_LENGTH] = {0};
	TCHAR *szFind = NULL;
	int nCurrentPortNum = 0;

	_tcscpy(szDeviceName, szDevice);
	_tcsupr(szDeviceName);
	szFind = _tcschr(szDeviceName, 'M');
	_ASSERTE(szFind != NULL);
	_tcscpy(szCOMNum, szFind+1);
	nCurrentPortNum = _ttoi(szCOMNum);
	return nCurrentPortNum;
}

// 20050215 Embert Tsai
// Get current mobile mode. But currently, topaz is not workable.
EMobileMode CSerialIO::GetMobileMode(){
	
	LPCTSTR szFunc = _T("CSerialIO::GetMobileMode");
	UCHAR szBuffer[4];
	DWORD dwWrited = 0;
	DWORD dwReadByte = 0;
	
	szBuffer[0] = 0x00;
	szBuffer[1] = 0x78;
	szBuffer[2] = 0xF0;
	szBuffer[3] = 0x7E;
	InternalWrite(szBuffer, 4, &dwWrited);
	Sleep(1);

	BYTE pbCMDRsp[READ_BUFFER_LEN];
	ZeroMemory(pbCMDRsp,READ_BUFFER_LEN);
	// 20050218 Embert Tsai, for complete packet
	if ( WaitandReadBuffer(pbCMDRsp, READ_BUFFER_LEN, 58, &dwReadByte) != ERROR_SUCCESS ){
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Read fails"));
		return MM_UNKNOW;
	}

	if ( pbCMDRsp[0] != 0x00 ){
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Can\'t get phone mode."));
		return MM_UNKNOW;
	}
	char szVer[9];
	ZeroMemory(szVer,9);
	CopyMemory(szVer,pbCMDRsp+39,8);
	strlwr(szVer);

	if( (strstr(szVer,"ulysses") != NULL) || (strstr(szVer,"ulyc2a") != NULL) || (strstr(szVer,"ulyc2b") != NULL) || (strstr(szVer,"ulyb1") != NULL))
	{
		return MM_ULYSSES;
	}
	else if(strstr(szVer,"tpz") != NULL)
	{
		return MM_TOPAZ;
	}
	else if(strstr(szVer, "msm5105") != NULL)
	{
		return MM_DOMINGO;
	}
	else
	{
		return  MM_UNKNOW;
	}

	return MM_UNKNOW;
}

long CSerialIO::InternalWrite(const void* pData, size_t iLen, DWORD* pdwWritten /* = 0 */){

	LPCTSTR szFunc = _T("CSerialIO::InternalWrite");
	m_lLastError = ERROR_SUCCESS;
	// Use our own variable for read count
	DWORD dwWritten;
	if (pdwWritten == 0)
	{
		pdwWritten = &dwWritten;
	}
	// Reset the number of bytes written
	*pdwWritten = 0;
	// Check if the device is open
	if (m_hFile == 0)
	{
		m_lLastError = ERROR_INVALID_HANDLE;
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("COM port handle is null"));
		return m_lLastError;
	}

	OVERLAPPED ovInternal = {0};
	ovInternal.hEvent = m_hWriteEvent;

	m_csWrite.Lock();
	// Data buffer to write
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Write data"));
	LogCOMFuncBuffer(LOG_LEVEL_DEBUG, m_szCOM, szFunc, (void *)pData, iLen);
	// Write the data
	if (!::WriteFile(m_hFile,pData,iLen,pdwWritten,&ovInternal))
	{
		long lLastError = ::GetLastError();
		if (lLastError != ERROR_IO_PENDING)
		{
			m_lLastError = lLastError;
		}
		else
		{
			switch (::WaitForSingleObject(ovInternal.hEvent,INFINITE))
			{
			case WAIT_OBJECT_0:
				// The overlapped operation has completed
				if (!::GetOverlappedResult(m_hFile,&ovInternal,pdwWritten,FALSE))
				{
					m_lLastError = ::GetLastError();
				}
				break;

			case WAIT_TIMEOUT:
				::CancelIo(m_hFile);
				m_lLastError = ERROR_TIMEOUT;
				break;

			default:
				m_lLastError = ::GetLastError();
				break;
			}
		}
	}
	m_csWrite.Unlock();
	// Return successfully
	return m_lLastError;
}

// 20050218 Embert Tsai 
// Stop log, event, and message packet.
void CSerialIO::StopLogEventMessagePacket(){
	// Wait for all write process complete.
	DWORD dwLoopCount = 0;
	while ( m_dwCurWriteCount != 0){
		Sleep(200);
	}
	Sleep(200);	

	BYTE pbCMDRsp[READ_BUFFER_LEN];
	DWORD dwReadByte = 0; 

	for ( int i = 0 ; i < 1 ; i ++){
		InternalWrite("\x1f\xff\x00\x5e\xf6\x7e", sizeof("\x1f\xff\x00\x5e\xf6\x7e")-1);
		WaitandReadBuffer(pbCMDRsp, READ_BUFFER_LEN, 4);
		// CMD_CODE 96 Event Configuration Request
		InternalWrite( "\x60\x00\x12\x6A\x7E", sizeof("\x60\x00\x12\x6A\x7E")-1);
		WaitandReadBuffer(pbCMDRsp, READ_BUFFER_LEN, 4);
		// CMD_CODE 115 Logging Configuration Request
		InternalWrite("\x73\x00\x00\x00\x00\x00\x00\x00\xda\x81\x7e", sizeof("\x73\x00\x00\x00\x00\x00\x00\x00\xda\x81\x7e")-1);
		WaitandReadBuffer(pbCMDRsp, READ_BUFFER_LEN, 4);
	}
	// Wait for all packet completed.
	// Start reading all content from read buffer
	while ( dwLoopCount < 5){
		if ( m_dwBufStart != m_dwBufEnd){		
			CSerialIO::Read(pbCMDRsp, READ_BUFFER_LEN);
			dwLoopCount = 0;
		} else {
			dwLoopCount++;
		}
		Sleep(100);
	}
	
}

long CSerialIO::WaitandReadBuffer(void* pData, size_t iLen, DWORD dwExpectedLen, DWORD* pdwRead){
	LPCTSTR szFunc = _T("CSerialIO::WaitandReadBuffer");
	_ASSERTE( pData != NULL);
	_ASSERTE( iLen > 0 );
	// 20060105 Embert Tsai.
	// To fix infinite loop bug, add time out count for while loop.
	DWORD nCount = 0;
	DWORD nReadCountLimit = 20;
	DWORD dwRead = 0;
	DWORD dwRet = 0;

	if (pdwRead == 0)
	{
		pdwRead = &dwRead;
	}
	*pdwRead = 0;

	_ASSERTE(m_hWaitEvent == NULL);
	// Wait for read buffer complete
	
	m_hWaitEvent = ::CreateEvent(0, FALSE, FALSE, 0);
	dwRet = WaitForSingleObject(m_hWaitEvent, 2000);

	if ( WAIT_TIMEOUT == dwRet){
		// Read time out
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Read time out."));
		::CloseHandle(m_hWaitEvent);
		m_hWaitEvent = NULL;
		return -1;
	}
/*
	while ( ((m_dwBufStart-m_dwBufEnd) < dwExpectedLen) && ((nCount) < nReadCountLimit) ) {
		Sleep(100);
		nCount++;
	}
	Sleep(100);
*/
	
	::CloseHandle(m_hWaitEvent);
	m_hWaitEvent = NULL;

	return CSerialIO::Read(pData, iLen, pdwRead);

}

int CSerialIO::GetSpeedIndex(EBaudrate eBaudrate){
	for ( int i = 0 ; i < SPEED_ARRAY_SIZE; i ++){
		if ( eBaudrate == m_TestSpeed[i])
			return i;
	}
	return -1;
}

LPCTSTR CSerialIO::GetComport(void){
	_ASSERTE(m_szCOM[0] == 'C');
	return m_szCOM;
}

////////////////////////////////////////////////////////////////////////////
/*************************************************************************
 * Purpose: Get the platform ID 
 * Input  : NONE
 * Return : Please refer to CSerialIO::EPlatform enumeration value for details.
  * Exception: NONE
 * Note	  : 2007/11/13 first version created by Embert Tsai.
 ***************************************************************************/
////////////////////////////////////////////////////////////////////////////
CSerialIO::EPlatform CSerialIO::GetPlatformID(){
	LPCTSTR szFunc = _T("CSerialIO::GetPlatformID");
	UCHAR szBuffer[4];
	DWORD dwWrited = 0;
	DWORD dwReadByte = 0;

	m_bIsPreventOuterWrite = TRUE;
	m_bIsPreventOuterRead = TRUE;

	szBuffer[0] = 0x7C;
	szBuffer[1] = 0x93;
	szBuffer[2] = 0x49;
	szBuffer[3] = 0x7E;
	InternalWrite(szBuffer, 4, &dwWrited);
	
	BYTE pbCMDRsp[READ_BUFFER_LEN] = {0};
	// 20050218 Embert Tsai, for complete packet
	if ( WaitandReadBuffer(pbCMDRsp, READ_BUFFER_LEN, 39, &dwReadByte) != ERROR_SUCCESS ){
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Read fails"));
		m_bIsPreventOuterWrite = FALSE;
		m_bIsPreventOuterRead = FALSE;
		return CSerialIO::E_PLAT_NOT_FOUND;
	}
	
	LogCOMFuncBuffer(LOG_LEVEL_DEBUG, m_szCOM, szFunc, pbCMDRsp, READ_BUFFER_LEN);
	if ( pbCMDRsp[0] != 0x7C ){
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Can\'t get platform ID."));
		m_bIsPreventOuterWrite = FALSE;
		m_bIsPreventOuterRead = FALSE;
		return CSerialIO::E_PLAT_NOT_FOUND;
	}
	char szPlatformID[6] = {0};
	CopyMemory(szPlatformID,pbCMDRsp+12,5);
	strupr(szPlatformID);
	
	LogCOMFuncInfo(LOG_LEVEL_DEBUG, m_szCOM, szFunc, _T("Platform ID is %s."), szPlatformID);
	if( (strstr(szPlatformID,"H10") != NULL) || (strstr(szPlatformID,"M6280") != NULL) || (strstr(szPlatformID,"M6260") != NULL))
	{
		m_bIsPreventOuterWrite = FALSE;
		m_bIsPreventOuterRead = FALSE;
		return CSerialIO::E_PLAT_6280;
	}else{
		m_bIsPreventOuterWrite = FALSE;
		m_bIsPreventOuterRead = FALSE;
		return CSerialIO::E_PLAT_DEFAULT;
	}
	
	m_bIsPreventOuterWrite = FALSE;
	m_bIsPreventOuterRead = FALSE;
	return E_PLAT_NOT_FOUND;

}

////////////////////////////////////////////////////////////////////////////
/*************************************************************************
 * Purpose: Change mode from DIAG to DL for all MSM6000 and MSM6250 related platform.
 * Input  : NONE
 * Return : TRUE	-->run succsesfully.
 *			FALSE	-->mode change failed.
 * Exception: NONE
 * Note	  : 2007/11/13 first version created by Embert Tsai.
 ***************************************************************************/
////////////////////////////////////////////////////////////////////////////
int CSerialIO::InternalChange2DLDefault(){
	LPCTSTR szFunc = _T("InternalChange2DLDefault");
	_ASSERTE(m_eState == EDIAG);
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Change DIAG to DL"));
	// 20050218 Embert Tsai.
	// Prevent outer process to read and write com port when entering download.
	m_bIsPreventOuterWrite = TRUE;
	m_bIsPreventOuterRead = TRUE;
	Sleep(500);
	StopLogEventMessagePacket();
	EMobileMode nMobileMode = GetMobileMode();
	if ( ! ChangeToOffline() ){
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc,_T("Change to offline fails."));
		m_bIsPreventOuterWrite = FALSE;
		m_bIsPreventOuterRead = FALSE;
		return FALSE;
	}
	StopListener();
	Sleep(1000);	// 2004/09/21 Embert Tsai. Give mobile and driver more time to change to download mode.
	int i = 1;
	m_ePreferBaudRate = m_eBaudrate;
	m_nCurrentSpeedTry = GetSpeedIndex(m_ePreferBaudRate);
	for ( i = 1 ; i< 10 ; i+=i){
		if ( InternalOpen() != ERROR_SUCCESS ){
			Sleep(i * 1000);	// 2004/09/21 Embert Tsai. Give mobile and driver more time to change to download mode.
		} else {
			break;
		}
	}
	if ( i > 10 )
		return FALSE;
	
	BYTE pbCMDDL[4] = {0x3A,0xA1,0x6E,0x7E};
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Write DIAG command to change to DL mode."));
	::Sleep(1000);
	if(!InternalWrite(pbCMDDL,4))
	{
		if ( nMobileMode == MM_ULYSSES){
			InternalClose();
			Sleep(5000);	// 2004/09/21 Embert Tsai. Give mobile and driver more time to change to download mode.
		}
		m_bIsPreventOuterWrite = FALSE;
		m_bIsPreventOuterRead = FALSE;
		StartListener();
		int i = 0;
		while( (i++) < MODE_DETECTION_RETY_TIMES )
		{
			switch(m_eState)
			{
			case EStop:
			case EStart:
				break;
			case EDS:
				return FALSE;
			case EDIAG:
				return FALSE;
			case EDL:
				LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Change to DL successfully."));
				return TRUE;
			}
			Sleep(MODE_DETECTION_DELAY);
		}
		return FALSE;
	}
	
	m_bIsPreventOuterWrite = TRUE;
	m_bIsPreventOuterRead = TRUE;
	
	return FALSE;

}

////////////////////////////////////////////////////////////////////////////
/*************************************************************************
 * Purpose: Change mode from DIAG to DL for all 6280 related platform.
 * Input  : NONE
 * Return : TRUE	-->run successfully.
 *			FALSE	-->mode change failed.
 * Exception: NONE
 * Note	  : 2007/11/13 first version created by Embert
 ***************************************************************************/
////////////////////////////////////////////////////////////////////////////
int CSerialIO::InternalChange2DL6280(){

	LPCTSTR szFunc = _T("InternalChange2DL6280");
	_ASSERTE(m_eState == EDIAG);
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Change DIAG to DL"));
	// Prevent outer process to read and write com port when entering download.
	m_bIsPreventOuterWrite = TRUE;
	m_bIsPreventOuterRead = TRUE;
	StopLogEventMessagePacket();

	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("Write DIAG command to change to DL mode."));
	BYTE pbCMDDL[4] = {0x3A,0xA1,0x6E,0x7E};	// mode change command for all Qualcomm platform.
	if(!InternalWrite(pbCMDDL,4))
	{

		m_bIsPreventOuterWrite = FALSE;
		m_bIsPreventOuterRead = FALSE;
		m_bIsCOMReopen = FALSE;
		InternalResetCOM();	// Reset COM port status.
		m_eState = EStart;
		int i = 0;
		while( (i++) < MODE_DETECTION_RETY_TIMES )
		{
			switch(m_eState)
			{
			case EStop:
			case EStart:
				break;
			case EDS:
				return FALSE;
			case EDIAG:
				return FALSE;
			case EDL:
				LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Change to DL successfully."));
				return TRUE;
			}
			Sleep(MODE_DETECTION_DELAY);
		}
		return FALSE;
	}
	
	m_bIsPreventOuterWrite = TRUE;
	m_bIsPreventOuterRead = TRUE;
	
	return FALSE;
}

////////////////////////////////////////////////////////////////////////////
/*************************************************************************
 * Purpose: Rest all serial COM port setting and purge it. The parameters comes from QPST log.
 * Input  : NONE
 * Return : ERROR_SUCCESS -->run successfully.
 *			OTHERS  -->error.
 * Exception: NONE
 * Note	  : 2007/11/13 first version created by Embert
 ***************************************************************************/
////////////////////////////////////////////////////////////////////////////
int CSerialIO::InternalResetCOM(){

	// Set COM port event mask
	LPCTSTR szFunc = _T("CSerialIO::InternalResetCOM");

	if ( !::SetCommMask(m_hFile, EV_CTS | EV_DSR | EV_RLSD | EV_BREAK) ){
		m_lLastError = ::GetLastError();
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Fails in setting COM wait mask."));
		LogCOMFuncSystemError(m_szCOM,szFunc,m_lLastError);
		return m_lLastError;	
	}
	
	// Set Input/Ouput Queue Size
	if (!::SetupComm(m_hFile, SERIAL_QUEUE_SIZE, SERIAL_QUEUE_SIZE)){
		m_lLastError = ::GetLastError();
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("Fails in setting COM Input and Output queue size."));
		LogCOMFuncSystemError(m_szCOM,szFunc,m_lLastError);
		return m_lLastError;	
	}

	// Purge COM port buffer
	if(!::PurgeComm(m_hFile, PURGE_TXCLEAR |
							 PURGE_RXCLEAR |
							 PURGE_TXABORT |
							 PURGE_RXABORT) )
	{
		m_lLastError = ::GetLastError();
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("::PurgeComm failed."));
		LogCOMFuncSystemError(m_szCOM,szFunc,m_lLastError);
		return m_lLastError;	
	}

	// setup the DCB structure for the device
	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("GetCommState."));
	DCB dcb;
	if(!::GetCommState(m_hFile, &dcb))
	{
		m_lLastError = ::GetLastError();
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("::GetCommState failed."));
		LogCOMFuncSystemError( m_szCOM ,szFunc,m_lLastError);
		return m_lLastError;	
	}
	dcb.DCBlength = sizeof (DCB);
	dcb.BaudRate = m_eBaudrate;
	dcb.fBinary = TRUE;
	dcb.fParity = FALSE;
	// Enable RTS & DTR control signal to support power for data cable (PhoneJack)
	dcb.fRtsControl = RTS_CONTROL_ENABLE;
	dcb.fDtrControl = DTR_CONTROL_ENABLE;
	dcb.fOutxCtsFlow = FALSE;
	dcb.fOutxDsrFlow = FALSE;
	dcb.fDsrSensitivity = FALSE;
	dcb.fTXContinueOnXoff = FALSE;
	dcb.fOutX = FALSE;
	dcb.fInX = FALSE;
	dcb.fErrorChar = FALSE;
	dcb.fNull = FALSE;
	dcb.fAbortOnError = TRUE;  //  check with ClearCommError ()
	dcb.XonLim = 0;  // don't care
	dcb.XoffLim = 0;  //  don't care
	dcb.ByteSize = 8;
	dcb.Parity = NOPARITY;
	dcb.StopBits = ONESTOPBIT;
	dcb.XonChar = 0;  //  don't care
	dcb.XoffChar = 0;  //  don't care
	dcb.ErrorChar = 0;  //  don't care
	dcb.EofChar = 0x00;  //  20071113 Embert Tsai. Change for 6280.
	dcb.EvtChar = 0x7E;  //  should signal EV_RXFLAG

	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("SetCommState."));
	if(!::SetCommState(m_hFile, &dcb))
	{
		m_lLastError = ::GetLastError();
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("::SetCommState failed."));
		LogCOMFuncSystemError( m_szCOM, szFunc, m_lLastError);
		return m_lLastError;	
	}

	// The following default value are changed according to QPST log.
	COMMTIMEOUTS cto;
	cto.ReadIntervalTimeout = DEF_READ_INTERVAL_TIMEOUT;
	cto.ReadTotalTimeoutMultiplier = DEF_READ_TOTAL_TIMEOUT_MULTIPLIER;
	cto.ReadTotalTimeoutConstant = DEF_READ_TOTAL_TIMEOUT_CONSTANT;
	cto.WriteTotalTimeoutMultiplier = DEF_WRITE_TOTAL_TIMEOUT_MULTIPLIER;
	cto.WriteTotalTimeoutConstant = DEF_WRITE_TOTAL_CONSTANT;

	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("GetCommTimeOut."));
	if (!::SetCommTimeouts(m_hFile,&cto))
	{
		m_lLastError = ::GetLastError();
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("::SetCommTimeouts failed."));
		LogCOMFuncSystemError( m_szCOM, szFunc, m_lLastError);
		return m_lLastError;	
	}

	LogCOMFuncInfo(LOG_LEVEL_WARNING, m_szCOM, szFunc, _T("PurgeComm."));
	if(!::PurgeComm(m_hFile, PURGE_TXCLEAR |
							 PURGE_RXCLEAR |
							 PURGE_TXABORT |
							 PURGE_RXABORT) )
	{
		m_lLastError = ::GetLastError();
		LogCOMFuncInfo(LOG_LEVEL_ERROR, m_szCOM, szFunc, _T("::PurgeComm failed."));
		LogCOMFuncSystemError(m_szCOM,szFunc,m_lLastError);
		return m_lLastError;	
	}

	return ERROR_SUCCESS;
}